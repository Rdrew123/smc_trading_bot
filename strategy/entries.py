from strategy.structure import detect_swing_high_low, detect_choch_bos
from strategy.order_blocks import detect_order_blocks
from strategy.fvg import detect_fvg
import time

TIMEFRAMES = ["1d", "4h", "1h", "30m", "15m", "5m", "1m"]

def get_market_bias(data_dict):
    """
    Determines the higher timeframe bias (bullish/bearish/neutral)
    """
    for tf in ["1d", "4h"]:
        df = data_dict[tf]
        swing_highs, swing_lows = detect_swing_high_low(df)
        if not swing_highs or not swing_lows:
            continue
        last_high, last_low = swing_highs[-1][1], swing_lows[-1][1]
        if df['close'].iloc[-1] > last_high:
            return "bullish"
        elif df['close'].iloc[-1] < last_low:
            return "bearish"
    return "neutral"

def detect_choch_bos_multi_tf(data_dict):
    """
    Detect CHoCH and BOS on all timeframes
    """
    all_events = {}
    for tf, df in data_dict.items():
        swing_highs, swing_lows = detect_swing_high_low(df)
        choch, bos = detect_choch_bos(df, swing_highs, swing_lows)
        all_events[tf] = {"choch": choch, "bos": bos}
    return all_events

def detect_valid_entry_multi_tf(symbol, data_dict, broker_name):
    """
    Checks for valid SMC entry across all timeframes and returns dict
    """
    df_1m = data_dict.get("1m")
    if df_1m is None or df_1m.empty:
        return None

    market_bias = get_market_bias(data_dict)
    choch_bos = detect_choch_bos_multi_tf(data_dict)
    ob = detect_order_blocks(df_1m)
    fvg = detect_fvg(df_1m)

    # Look for entries only in direction of bias
    for level in ob + fvg:
        level_dir = level.get('direction') or level.get('type', '')
        if level_dir != market_bias:
            continue

        # Entry at current 1m close
        entry_price = df_1m['close'].iloc[-1]
        sl = df_1m['low'].iloc[-1] if market_bias=="bullish" else df_1m['high'].iloc[-1]

        # Take profits: simple measured moves (can be refined later)
        tp1 = entry_price + 0.5 if market_bias=="bullish" else entry_price - 0.5
        tp2 = entry_price + 1 if market_bias=="bullish" else entry_price - 1
        tp3 = entry_price + 1.5 if market_bias=="bullish" else entry_price - 1.5

        # Candle ID for duplicate prevention (timestamp of latest 1m candle)
        candle_id = int(time.time())  # simple unique ID per entry; can be replaced with timestamp

        # Chart path placeholder (to be generated by chart.py)
        chart_path = f"charts/{broker_name}_{symbol}_{candle_id}.png"

        return {
            "entry": entry_price,
            "sl": sl,
            "tp1": tp1,
            "tp2": tp2,
            "tp3": tp3,
            "chart_path": chart_path,
            "candle_id": candle_id
        }

    return None
